"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var websocket_1 = require("websocket");
var uuid_1 = require("uuid");
var config_1 = require("../config");
var nylas_1 = __importDefault(require("../nylas"));
var webhook_notification_1 = require("../models/webhook-notification");
/**
 * Create a webhook to the Nylas forwarding service which will pass messages to our websocket
 * @param callbackDomain The domain name of the callback
 * @param tunnelPath The path to the tunnel
 * @param triggers The list of triggers to subscribe to
 * @return The webhook details response from the API
 */
var buildTunnelWebhook = function (callbackDomain, tunnelPath, triggers) {
    var callbackUrl = "https://" + callbackDomain + "/" + tunnelPath;
    return nylas_1.default.webhooks
        .build({
        callbackUrl: callbackUrl,
        state: 'active',
        test: true,
        triggers: triggers,
    })
        .save();
};
/**
 * Open a webhook tunnel and register it with the Nylas API
 * 1. Creates a UUID
 * 2. Opens a websocket connection to Nylas' webhook forwarding service,
 *    with the UUID as a header
 * 3. Creates a new webhook pointed at the forwarding service with the UUID as the path
 *
 * When an event is received by the forwarding service, it will push directly to this websocket
 * connection
 *
 * @param config Configuration for the webhook tunnel, including callback functions,
 * region, and events to subscribe to
 * @return The webhook details response from the API
 */
exports.openWebhookTunnel = function (config) {
    var triggers = config.triggers || config_1.DEFAULT_WEBHOOK_TRIGGERS;
    var region = config.region || config_1.DEFAULT_REGION;
    var _a = config_1.regionConfig[region], websocketDomain = _a.websocketDomain, callbackDomain = _a.callbackDomain;
    // This UUID will map our websocket to a webhook in the forwarding server
    var tunnelId = uuid_1.v4();
    var client = new websocket_1.client({ closeTimeout: 60000 });
    client.on('connectFailed', function (error) {
        config.onConnectFail && config.onConnectFail(error);
    });
    client.on('connect', function (connection) {
        config.onConnect && config.onConnect(client);
        connection.on('error', function (error) {
            config.onError && config.onError(error);
        });
        connection.on('close', function () {
            config.onClose && config.onClose(client);
        });
        connection.on('message', function (message) {
            // This shouldn't happen. If any of these are seen, open an issue
            if (message.type === 'binary') {
                config.onError &&
                    config.onError(new Error('Unknown binary message received'));
                return;
            }
            try {
                var req = JSON.parse(message.utf8Data);
                var deltas = JSON.parse(req.body).deltas;
                deltas.forEach(function (delta) {
                    return config.onMessage(new webhook_notification_1.WebhookDelta().fromJSON(delta));
                });
            }
            catch (e) {
                config.onError &&
                    config.onError(new Error("Error converting Nylas websocket event to JSON: " + (e &&
                        e.message)));
            }
        });
    });
    client.connect("wss://" + websocketDomain, undefined, undefined, {
        'Client-Id': nylas_1.default.clientId,
        'Client-Secret': nylas_1.default.clientSecret,
        'Tunnel-Id': tunnelId,
        Region: region,
    });
    return buildTunnelWebhook(callbackDomain, tunnelId, triggers);
};
